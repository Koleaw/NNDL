
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Telco Churn Classifier — TensorFlow.js (в браузере)</title>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-vis@1.5.1/dist/tfjs-vis.umd.min.js"></script>
  <style>
    :root{--bg:#0f1229;--card:#161a34;--border:#2a2f52;--text:#e7ebff;--muted:#a8b0d9}
    *{box-sizing:border-box}body{margin:0;background:radial-gradient(1200px 800px at 15% -10%,#1b2156,var(--bg));color:var(--text);font:15px/1.5 system-ui,-apple-system,Segoe UI,Inter,Roboto,Arial,sans-serif}
    .wrap{max-width:1240px;margin:24px auto 96px;padding:0 16px}
    header{display:flex;gap:14px;align-items:center;margin-bottom:16px}
    .logo{width:42px;height:42px;border-radius:12px;background:linear-gradient(135deg,#65b3ff,#a855f7);display:flex;align-items:center;justify-content:center;color:#fff;font-weight:800}
    h1{margin:0;font-size:20px}.muted{color:var(--muted)}
    .grid{display:grid;gap:14px;grid-template-columns:repeat(12,1fr)}
    .card{grid-column:span 12;background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,.01));border:1px solid var(--border);border-radius:16px;padding:14px}
    .cols-6{grid-column:span 6}.cols-4{grid-column:span 4}.cols-8{grid-column:span 8}
    .btn{appearance:none;border:1px solid var(--border);background:rgba(255,255,255,.03);color:var(--text);border-radius:12px;padding:8px 12px;cursor:pointer}
    input[type="number"],select{background:rgba(255,255,255,.03);border:1px solid var(--border);border-radius:10px;color:var(--text);padding:6px 8px}
    .pill{display:inline-block;border:1px solid var(--border);border-radius:999px;padding:4px 10px;color:var(--muted);background:rgba(255,255,255,.03)}
    table{width:100%;border-collapse:collapse;border:1px solid var(--border);border-radius:10px;overflow:hidden}
    th,td{padding:8px 10px;border-bottom:1px solid var(--border)}th{text-align:left;color:var(--muted);background:rgba(255,255,255,.03)}
    .surface{min-height:240px;border:1px dashed var(--border);border-radius:12px;padding:8px}
    .kpis{display:flex;gap:12px;flex-wrap:wrap}
    .kpi{background:rgba(255,255,255,.03);border:1px solid var(--border);padding:10px 12px;border-radius:12px;min-width:160px}
    .hstack{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="logo">AI</div>
      <div>
        <h1>Telco Churn Classifier — TensorFlow.js (в браузере)</h1>
        <div class="muted">Загрузите CSV (IBM Telco Churn). Обучите простую MLP-модель прямо в браузере. Без сервера и установки.</div>
      </div>
    </header>

    <div class="grid">
      <section class="card cols-12">
        <h2>1) Данные</h2>
        <div class="hstack">
          <input id="fileCsv" type="file" accept=".csv,text/csv"/>
          <button class="btn" id="btnLoad">Загрузить CSV</button>
          <span id="statusLoad" class="pill">Жду файл…</span>
        </div>
        <div id="headPreview" style="margin-top:8px"></div>
      </section>

      <section class="card cols-6">
        <h2>2) Настройки</h2>
        <div class="hstack">
          <label>Тест % <input id="testSplit" type="number" min="10" max="40" value="20"/></label>
          <label>Эпохи <input id="epochs" type="number" min="5" max="200" value="35"/></label>
          <label>Батч <input id="batch" type="number" min="8" max="256" step="8" value="32"/></label>
          <label>Слои: 
            <select id="layers">
              <option value="32,16" selected>32 → 16</option>
              <option value="64,32">64 → 32</option>
              <option value="16,8">16 → 8</option>
            </select>
          </label>
          <label><input id="balance" type="checkbox" checked/> Баланс классов (оверсэмпл меньшинства)</label>
          <button class="btn" id="btnTrain">Запустить обучение</button>
          <span id="statusTrain" class="pill">Готов</span>
        </div>
        <div id="trainVis" class="surface" style="margin-top:8px"></div>
      </section>

      <section class="card cols-6">
        <h2>3) Оценка (hold-out)</h2>
        <div class="hstack">
          <label>Порог <input id="thr" type="range" min="1" max="99" value="50"/></label>
          <span id="thrVal" class="pill">0.50</span>
          <button class="btn" id="btnBestThr">Лучший F1</button>
          <button class="btn" id="btnSave">Сохранить модель</button>
        </div>
        <div class="kpis" id="kpis" style="margin-top:8px"></div>
        <div id="cm" class="surface" style="margin-top:8px"></div>
      </section>

      <section class="card cols-12">
        <h2>4) Прогноз & Экспорт</h2>
        <div class="hstack">
          <button class="btn" id="btnPredict">Посчитать прогнозы для всего CSV</button>
          <button class="btn" id="btnDownloadPred">Скачать предсказания (CSV)</button>
          <span id="statusPred" class="pill">Пока нет предсказаний</span>
        </div>
        <div id="tailPreview" style="margin-top:8px"></div>
      </section>

      <section class="card cols-12">
        <h2>Примечания</h2>
        <ul>
          <li>Препроцессинг: z-score для числовых (<code>tenure</code>, <code>MonthlyCharges</code>, <code>TotalCharges</code>), one-hot для категориальных. 
              Значения “No internet/phone service” схлопываются в “No”. Пустые <code>TotalCharges</code> → 0.</li>
          <li>Целевое: <code>Churn</code> (Yes/No). При включённом “Баланс классов” делаем оверсэмпл меньшинства.</li>
          <li>Метрики: Accuracy, Precision, Recall, F1, ROC-AUC; матрица ошибок зависит от порога.</li>
        </ul>
      </section>
    </div>
  </div>

  <script>
    // ---------- helpers ----------
    const el=(t,p={},...kids)=>{const n=document.createElement(t);Object.assign(n,p);kids.forEach(k=>n.append(k?.nodeType?k:document.createTextNode(k??'')));return n};
    const clear=n=>{while(n.firstChild)n.removeChild(n.firstChild)};

    function table(container, rows, cols){
      clear(container);
      const tbl=el('table'), thead=el('thead'), trh=el('tr');
      cols.forEach(c=>trh.appendChild(el('th',{},c))); thead.appendChild(trh); tbl.appendChild(thead);
      const tb=el('tbody');
      rows.forEach(r=>{const tr=el('tr'); cols.forEach(c=>tr.appendChild(el('td',{},String(r[c]??'')))); tb.appendChild(tr);});
      tbl.appendChild(tb); container.appendChild(tbl);
    }
    function toCSV(rows){
      if(!rows.length) return '';
      const cols=Object.keys(rows[0]);
      const esc=v=>(''+v).replaceAll('"','""');
      return [cols.join(','), ...rows.map(r=>cols.map(c=>`"${esc(r[c]??'')}"`).join(','))].join('\\n');
    }
    function shuffleInPlace(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

    // ---------- data parsing ----------
    const NUM=['tenure','MonthlyCharges','TotalCharges'];
    const CAT=['gender','SeniorCitizen','Partner','Dependents','PhoneService','MultipleLines','InternetService','OnlineSecurity','OnlineBackup','DeviceProtection','TechSupport','StreamingTV','StreamingMovies','Contract','PaperlessBilling','PaymentMethod'];
    const DROP=['customerID']; // id-only
    function cleanRow(r){
      const rc={...r};
      const trim=v=> typeof v==='string'? v.trim(): v;
      // collapse "No internet service" etc
      const collapse=['MultipleLines','OnlineSecurity','OnlineBackup','DeviceProtection','TechSupport','StreamingTV','StreamingMovies'];
      collapse.forEach(k=>{ const v=trim(rc[k]); if(v==='No internet service'||v==='No phone service') rc[k]='No'; });
      // numeric
      rc.tenure = Number(trim(rc.tenure));
      rc.MonthlyCharges = Number(trim(rc.MonthlyCharges));
      const t = trim(rc.TotalCharges);
      rc.TotalCharges = t===''||t==null? 0 : Number(t);
      rc.Churn = rc.Churn!=null? String(trim(rc.Churn)) : undefined;
      return rc;
    }
    function parseCSV(file){
      return new Promise((res,rej)=>{
        Papa.parse(file,{header:true,dynamicTyping:false,skipEmptyLines:true,complete:r=>{
          const rows=(r.data||[]).filter(x=>Object.values(x).some(v=>v!==''&&v!=null)).map(cleanRow);
          const cols=r.meta?.fields||Object.keys(rows[0]||{});
          res({rows,cols});
        },error:rej});
      });
    }

    // ---------- global state ----------
    const UI={
      file:()=>document.getElementById('fileCsv'), btnLoad:()=>document.getElementById('btnLoad'), statusLoad:()=>document.getElementById('statusLoad'),
      head:()=>document.getElementById('headPreview'),
      testSplit:()=>document.getElementById('testSplit'), epochs:()=>document.getElementById('epochs'), batch:()=>document.getElementById('batch'),
      layers:()=>document.getElementById('layers'), balance:()=>document.getElementById('balance'),
      btnTrain:()=>document.getElementById('btnTrain'), statusTrain:()=>document.getElementById('statusTrain'), trainVis:()=>document.getElementById('trainVis'),
      thr:()=>document.getElementById('thr'), thrVal:()=>document.getElementById('thrVal'), btnBestThr:()=>document.getElementById('btnBestThr'),
      kpis:()=>document.getElementById('kpis'), cm:()=>document.getElementById('cm'), btnSave:()=>document.getElementById('btnSave'),
      btnPredict:()=>document.getElementById('btnPredict'), btnDownloadPred:()=>document.getElementById('btnDownloadPred'), statusPred:()=>document.getElementById('statusPred'),
      tail:()=>document.getElementById('tailPreview')
    };
    const S={raw:[], cats:{}, mean:{}, std:{}, model:null, Xtr:null, ytr:null, Xte:null, yte:null, thr:0.5, preds:null};

    function showHead(rows){
      table(UI.head(), rows.slice(0,5), Object.keys(rows[0]||{}));
    }

    // ---------- preprocessing ----------
    function fitPreprocess(trainRows){
      // categories per column
      S.cats={};
      for(const c of CAT){
        S.cats[c]=[...new Set(trainRows.map(r=>String(r[c])))];
      }
      // z-score params for numeric
      S.mean={}; S.std={};
      for(const c of NUM){
        const v=trainRows.map(r=>Number(r[c]));
        const n=v.length, m=v.reduce((s,x)=>s+x,0)/Math.max(1,n);
        const sd=Math.sqrt(v.reduce((s,x)=>s+(x-m)**2,0)/Math.max(1,n-1))||1;
        S.mean[c]=m; S.std[c]=sd;
      }
    }
    function rowToX(r){
      const x=[];
      for(const c of NUM){ x.push( (Number(r[c])-S.mean[c])/S.std[c] ); }
      for(const c of CAT){
        const cats=S.cats[c];
        const val=String(r[c]);
        for(const u of cats) x.push( val===u ? 1 : 0 );
      }
      return x;
    }
    function buildXY(rows){
      const X=[], y=[];
      for(const r of rows){
        X.push(rowToX(r));
        y.push(r.Churn==='Yes'?1:0);
      }
      return {X:tf.tensor2d(X), y:tf.tensor2d(y,[y.length,1])};
    }

    function splitTrainTest(rows, testPct){
      const idx=[...rows.keys()]; shuffleInPlace(idx);
      const n=rows.length, nTest=Math.floor(n*testPct/100);
      const test=idx.slice(0,nTest).map(i=>rows[i]);
      const train=idx.slice(nTest).map(i=>rows[i]);
      return {train,test};
    }

    function oversample(trainRows){
      const yes=trainRows.filter(r=>r.Churn==='Yes');
      const no=trainRows.filter(r=>r.Churn!=='Yes');
      if(yes.length===0||no.length===0) return trainRows;
      const target=no.length;
      const ext=[];
      while(yes.length+ext.length < target){
        ext.push( yes[Math.floor(Math.random()*yes.length)] );
      }
      return shuffleInPlace(trainRows.concat(ext));
    }

    // ---------- metrics ----------
    function cmMetrics(yTrue, yProb, thr){
      const n=yTrue.length; let tp=0,tn=0,fp=0,fn=0;
      for(let i=0;i<n;i++){ const p=yProb[i]>=thr?1:0; const t=yTrue[i];
        if(p===1&&t===1) tp++; else if(p===1&&t===0) fp++; else if(p===0&&t===1) fn++; else tn++; }
      const acc=(tp+tn)/n;
      const prec=tp/(tp+fp||1); const rec=tp/(tp+fn||1); const f1=2*prec*rec/(prec+rec||1);
      return {tp,tn,fp,fn,acc,prec,rec,f1};
    }
    function rocAuc(yTrue, yProb){
      const pairs=yProb.map((p,i)=>[p,yTrue[i]]).sort((a,b)=>b[0]-a[0]);
      let tp=0, fp=0; const P=yTrue.reduce((s,t)=>s+t,0), N=yTrue.length-P;
      let auc=0, prevFpr=0, prevTpr=0;
      for(const [p,t] of pairs){
        if(t===1) tp++; else fp++;
        const tpr=tp/(P||1), fpr=fp/(N||1);
        auc += (fpr-prevFpr)*(tpr+prevTpr)/2;
        prevFpr=fpr; prevTpr=tpr;
      }
      return 1-auc; // integrate high->low
    }
    function bestF1Threshold(yTrue,yProb){
      let best=0.5, bestF1=-1;
      for(let t=0.05;t<=0.95;t+=0.01){
        const m=cmMetrics(yTrue,yProb,t);
        if(m.f1>bestF1){bestF1=m.f1; best=t;}
      }
      return {thr:best, f1:bestF1};
    }

    // ---------- model ----------
    function buildModel(inputDim, layersSpec){
      const model=tf.sequential();
      const [u1,u2]=layersSpec.split(',').map(x=>parseInt(x.trim(),10));
      model.add(tf.layers.dense({units:u1, activation:'relu', inputShape:[inputDim]}));
      model.add(tf.layers.dropout({rate:0.2}));
      model.add(tf.layers.dense({units:u2, activation:'relu'}));
      model.add(tf.layers.dropout({rate:0.1}));
      model.add(tf.layers.dense({units:1, activation:'sigmoid'}));
      model.compile({optimizer:tf.train.adam(0.001), loss:'binaryCrossentropy', metrics:['accuracy']});
      return model;
    }

    function renderKPIs(m, auc){
      const fmt=(x)=> (isFinite(x)? (x*100).toFixed(1)+'%' : '—');
      clear(UI.kpis());
      const items=[
        ['Accuracy', fmt(m.acc)], ['Precision', fmt(m.prec)], ['Recall', fmt(m.rec)], ['F1', fmt(m.f1)], ['ROC-AUC', fmt(auc)]
      ];
      items.forEach(([k,v])=> UI.kpis().append(el('div',{className:'kpi'}, el('div',{className:'muted'},k), el('div',{style:'font-size:20px;font-weight:700'}, v))));
    }
    function renderCM(m){
      clear(UI.cm());
      const tbl=el('table'), trh=el('tr');
      ['','Предсказано 0','Предсказано 1'].forEach(s=>trh.appendChild(el('th',{},s))); tbl.appendChild(el('thead',{} , trh));
      const b=el('tbody');
      const r0=el('tr',{}, el('td',{},'Истинно 0'), el('td',{}, String(m.tn)), el('td',{}, String(m.fp)));
      const r1=el('tr',{}, el('td',{},'Истинно 1'), el('td',{}, String(m.fn)), el('td',{}, String(m.tp)));
      b.append(r0,r1); tbl.appendChild(b); UI.cm().append(tbl);
    }

    // ---------- wire up ----------
    UI.btnLoad().addEventListener('click', async()=>{
      const f=UI.file().files[0]; if(!f){ UI.statusLoad().textContent='Выберите CSV'; return; }
      UI.statusLoad().textContent='Парсинг…';
      const {rows}=await parseCSV(f);
      S.raw=rows;
      UI.statusLoad().textContent=`Загружено ✓ (${rows.length} строк)`;
      showHead(rows);
    });

    UI.thr().addEventListener('input', ()=>{
      S.thr = Number(UI.thr().value)/100;
      UI.thrVal().textContent=S.thr.toFixed(2);
      if(!S.preds || !S.yte) return;
      const m=cmMetrics(S.yte, S.preds, S.thr);
      const auc=rocAuc(S.yte, S.preds);
      renderKPIs(m, auc); renderCM(m);
    });

    UI.btnTrain().addEventListener('click', async()=>{
      if(S.raw.length===0){ alert('Сначала загрузите CSV'); return; }
      UI.statusTrain().textContent='Подготовка…';
      // split
      const {train, test}=splitTrainTest(S.raw, Number(UI.testSplit().value));
      const trBalanced = UI.balance().checked ? oversample(train) : train;
      fitPreprocess(trBalanced);
      // build XY
      const XYtr=buildXY(trBalanced), XYte=buildXY(test);
      S.Xtr=XYtr.X; S.ytr=XYtr.y; S.Xte=XYte.X; S.yte=Array.from(await XYte.y.data()).map(v=>Number(v));
      // model
      const inputDim=S.Xtr.shape[1];
      S.model=buildModel(inputDim, UI.layers().value);

      // train
      UI.statusTrain().textContent='Обучение…';
      const surface={name:'Обучение', tab:'Charts'};
      const hist=await S.model.fit(S.Xtr, S.ytr, {
        epochs:Number(UI.epochs().value),
        batchSize:Number(UI.batch().value),
        shuffle:true,
        validationData:[S.Xte, tf.tensor2d(S.yte,[S.yte.length,1])],
        callbacks: tfvis.show.fitCallbacks(surface, ['loss','val_loss','acc','val_acc'], {callbacks:['onEpochEnd']})
      });
      UI.statusTrain().textContent='Обучено ✓';

      // evaluate
      const probs = Array.from(await S.model.predict(S.Xte).data());
      S.preds = probs;
      // best F1
      const b=bestF1Threshold(S.yte, probs);
      S.thr=b.thr; UI.thr().value = Math.round(S.thr*100); UI.thrVal().textContent=S.thr.toFixed(2);
      const m=cmMetrics(S.yte, probs, S.thr);
      const auc=rocAuc(S.yte, probs);
      renderKPIs(m, auc); renderCM(m);
      UI.statusPred().textContent='Готово к прогнозу всего CSV';
    });

    UI.btnBestThr().addEventListener('click', ()=>{
      if(!S.preds){ return; }
      const b=bestF1Threshold(S.yte, S.preds);
      S.thr=b.thr; UI.thr().value = Math.round(S.thr*100); UI.thrVal().textContent=S.thr.toFixed(2);
      const m=cmMetrics(S.yte, S.preds, S.thr);
      const auc=rocAuc(S.yte, S.preds);
      renderKPIs(m, auc); renderCM(m);
    });

    UI.btnPredict().addEventListener('click', async()=>{
      if(!S.model){ alert('Сначала обучите модель'); return; }
      const preds=[];
      for(const r of S.raw){
        const p=await tf.tidy(()=> S.model.predict(tf.tensor2d([rowToX(r)])).dataSync()[0] );
        preds.push({customerID:r.customerID, prob: p, pred: (p>=S.thr ? 'Yes':'No')});
      }
      S.predRows = S.raw.map((r,i)=> ({...r, Pred_Prob: preds[i].prob.toFixed(4), Pred_Label: preds[i].pred}) );
      UI.statusPred().textContent=`Предсказано ✓ (${S.predRows.length} строк)`;
      table(UI.tail(), S.predRows.slice(-5), Object.keys(S.predRows[0]));
    });

    UI.btnDownloadPred().addEventListener('click', ()=>{
      if(!S.predRows){ alert('Нет предсказаний'); return; }
      const csv=toCSV(S.predRows);
      const blob=new Blob([csv], {type:'text/csv'});
      const url=URL.createObjectURL(blob); const a=document.createElement('a');
      a.href=url; a.download='telco_churn_predictions.csv'; document.body.appendChild(a); a.click(); URL.revokeObjectURL(url); a.remove();
    });

    UI.btnSave().addEventListener('click', async()=>{
      if(!S.model){ alert('Сначала обучите модель'); return; }
      // Save model and preprocessing params together
      const prep={cats:S.cats, mean:S.mean, std:S.std, thr:S.thr, num:NUM, cat:CAT, drop:DROP};
      const blob=new Blob([JSON.stringify(prep,null,2)],{type:'application/json'});
      const url=URL.createObjectURL(blob); const a=document.createElement('a');
      a.href=url; a.download='preprocessing.json'; document.body.appendChild(a); a.click(); URL.revokeObjectURL(url); a.remove();
      await S.model.save('downloads://telco_churn_tfjs_model');
    });
  </script>
</body>
</html>
